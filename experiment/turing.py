"""
    아주 중요한 사실 중 하나는, 튜링 기계로는 메모리 인덱스를 사용할 수 없다는 것이다.
    만약 튜링 기계에 메모리 인덱스를 부여하면 어떻게 될까?
    알 수 없다.
    튜링 머신에서 이진 덧셈을 구현할 수 있을까?
    즉 qa0b├M*q(a+b)인 튜링 머신을 찾을 수 있는가?
    그러므로 튜링 머신은 함수 그 자체를 구현한 것임을 알 수 있다.
    먼저 구현하기 편하도록 리틀 엔디안 방식의 구조를 취하도록 하자.
    그리고 튜링 머신이 가질 수 있는 상태를 튜플로 표현하자.
    어차피 유한하기만 하면 된다.

    또한 튜링 머신이 수행할 수 있는 연산을 재귀적으로 정의하자.
    애초에 튜링 머신은 어지간하면 항상 재귀적이다.

     먼저 튜링 머신의 상태 튜플의 첫 번째 원소는 하고 있는 행동이다.
    튜링 머신은 초기 상태에서 덧셈을 수행하기 위해 오른쪽으로 이동하거나,
    혹은 덧셈을 모두 수행한 후 다시 원래 자리로 돌아오고자 왼쪽으로 이동한다.
    그러므로 튜링 머신의 이동 방향은 어쨌든 오직 첫 번째 원소에만 종속적이다.

    #  다음으로 튜링 머신이 가지는 상태의 두 번째 원소는 피연산자 순서이다.
    # 덧셈 연산은 오직 두 개의 피연산자를 가진다. 초기값은 0이다.

     다음으로 튜링 머신이 가지는 세 번째 원소는 캐리어이다.
    이는 오직 0 혹은 1이다. 초기값은 0이다.

     다음으로 튜링 머신이 가지는 네 번째 원소는 이진 논리합이다.

     마지막으로 튜링 머신이 가지는 다섯 번째 원소는 현재 읽은 수가 LSB인지이다. 초기값은 1이다.

    튜링 머신이 읽을 수 있는 알파벳은 네 개이다.
    1. 공백
    2. 구분자
    3. 0
    4. 1

    각 알파벳에 대한 행동표는 아래와 같다.
    1. 만약 공백이라면, 이동 방향을 바꾼다.
    만약 원래 이동 방향이 오른쪽이었다면, 이진 연산 결과를 현재 위치에 적고, 캐리어를 이진 연산 결과로 옮기고, 캐리어를 초기화한다.
    만약 원래 이동 방향이 왼쪽이었다면, 만약 LSB가 1이라면, 종료한다. 아니라면, LSB를 1로 한다.
    2. 만약 구분자라면, LSB 마스크를 1로 한다.
    3. 만약 0이거나 1이라면, LSB마스크를 0으로 한다. 그리고 오직 이동 순서가 오른쪽일 때, 
        a. 만약 LSB가 아니라면, 쓰거나 읽지 않는다.
        b. 만약 0이라면 쓰거나 읽지 않는다.
        c. 만약 1이라면, 이진 논리합이 0일 때에는 단순히 이진 논리합을 1로 바꾼다. 이진 논리합이 1이라면, 캐리어를 1로 하고 이진 논리합을 0으로 한다.

    위 행동표를 정리해보자.
    1. 공백, 오른쪽, S=0+1,C=0+1    ... 4개
    2. 공백, 왼쪽, LSB=0+1          ... 2개
    3. 구분자                       ... 1개
    4. 

    튜링 머신은 다음과 같은 행동을 수행하는 기계이다.
    1. 현재 테이프의 값과 머신의 상태를 읽는다.
    2. 새로운 값을 쓴다.
    3. 현재 상태를 바꾼다.
    4. 이동한다.

    그러므로 튜링 머신의 행동표는
    1. 테이프의 값
    2. 머신의 상태
    3. 쓸 새로운 값
    4. 바꿀 새로운 상태
    5. 이동할 방향
    이렇게 5-Tuple들로 이뤄진다.
"""
